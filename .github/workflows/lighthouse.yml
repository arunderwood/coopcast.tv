name: Lighthouse CI

on:
  pull_request:
    branches: [ "main" ]
  push:
    branches: [ "main" ]

jobs:
  lighthouse:
    name: Lighthouse Mobile Testing
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      statuses: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '22'
          cache: 'npm'
          cache-dependency-path: './frontend/package-lock.json'

      - name: Install dependencies
        working-directory: ./frontend
        run: npm ci

      - name: Determine test URL
        id: url
        run: |
          if [ "${{ github.event_name }}" = "push" ] && [ "${{ github.ref }}" = "refs/heads/main" ]; then
            echo "url=https://coopcast.tv" >> $GITHUB_OUTPUT
            echo "Testing production site: https://coopcast.tv"
          else
            echo "url=preview" >> $GITHUB_OUTPUT
            echo "Will wait for Cloudflare preview deployment"
          fi

      - name: Wait for Cloudflare deployment
        uses: actions/github-script@v8
        id: cloudflare
        if: steps.url.outputs.url == 'preview'
        with:
          script: |
            const maxAttempts = 30; // 5 minutes max
            const delay = 10000; // 10 seconds

            // Get current commit SHA (first 7 chars to match Cloudflare's format)
            const currentSha = context.payload.pull_request.head.sha.substring(0, 7);
            console.log(`Waiting for Cloudflare deployment of commit ${currentSha}...`);

            for (let i = 0; i < maxAttempts; i++) {
              const comments = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number
              });

              const cfComment = comments.data.find(c =>
                c.user.login === 'cloudflare-workers-and-pages[bot]' &&
                c.body.includes('Deploy successful!') &&
                c.body.includes(currentSha) // Verify it's for THIS commit
              );

              if (cfComment) {
                // Extract Preview URL (commit-specific, not branch URL)
                const match = cfComment.body.match(/href='(https:\/\/[a-f0-9]+\.coopcast-tv\.pages\.dev)'/);
                if (match) {
                  const previewUrl = match[1];
                  console.log(`Found Cloudflare preview URL for ${currentSha}: ${previewUrl}`);
                  core.setOutput('url', previewUrl);
                  return previewUrl;
                }
              }

              console.log(`Attempt ${i + 1}/${maxAttempts}: Deployment for ${currentSha} not ready yet...`);
              await new Promise(resolve => setTimeout(resolve, delay));
            }

            throw new Error(`Cloudflare deployment timeout for commit ${currentSha} after 5 minutes`);

      - name: Run Lighthouse CI
        working-directory: ./frontend
        run: |
          if [ "${{ steps.url.outputs.url }}" = "preview" ]; then
            BASE_URL="${{ steps.cloudflare.outputs.url }}"
          else
            BASE_URL="${{ steps.url.outputs.url }}"
          fi
          npx lhci autorun --config=./lighthouserc.json \
            --collect.url="$BASE_URL" \
            --collect.url="$BASE_URL/family-tree"
        env:
          LHCI_GITHUB_APP_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Debug LHCI output
        if: always()
        working-directory: ./frontend
        run: |
          echo "=== LHCI output directory contents ==="
          ls -la .lighthouseci/ || echo "Directory not found"
          echo ""
          echo "=== Checking category scores in reports ==="
          for f in .lighthouseci/lhr-*.json; do
            if [ -f "$f" ]; then
              echo "File: $f"
              cat "$f" | jq '{
                url: .finalUrl,
                performance: .categories.performance.score,
                accessibility: .categories.accessibility.score,
                "best-practices": .categories["best-practices"].score,
                seo: .categories.seo.score
              }' 2>/dev/null || echo "Failed to parse"
            fi
          done

      - name: Upload Lighthouse reports
        uses: actions/upload-artifact@v6
        if: always()
        with:
          name: lighthouse-reports
          path: |
            frontend/.lighthouseci/**/*.json
            frontend/.lighthouseci/**/*.html
          retention-days: 30
          if-no-files-found: warn

      - name: Add PR comment with results
        uses: actions/github-script@v8
        if: github.event_name == 'pull_request' && always()
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            // Find the manifest file
            const lhciDir = 'frontend/.lighthouseci';
            const manifestPath = path.join(lhciDir, 'manifest.json');

            if (!fs.existsSync(manifestPath)) {
              console.log('No manifest.json found, skipping comment');
              return;
            }

            const manifest = JSON.parse(fs.readFileSync(manifestPath, 'utf8'));

            // Get representative runs only (one per URL)
            const representativeRuns = manifest.filter(entry => entry.isRepresentativeRun);
            // Fallback: if no representative runs marked, dedupe by URL (take first of each)
            const runsToShow = representativeRuns.length > 0 ? representativeRuns :
              [...new Map(manifest.map(e => [new URL(JSON.parse(fs.readFileSync(e.jsonPath, 'utf8')).finalUrl).pathname, e])).values()];

            const formatScore = (score) => {
              if (score === null || score === undefined) return 'N/A';
              const pct = Math.round(score * 100);
              if (pct >= 90) return `ðŸŸ¢ ${pct}`;
              if (pct >= 50) return `ðŸŸ¡ ${pct}`;
              return `ðŸ”´ ${pct}`;
            };

            // Build comment body
            let comment = '## ðŸ“± Lighthouse CI Mobile Report\n\n';
            comment += '| URL | Performance | Accessibility | Best Practices | SEO |\n';
            comment += '|-----|-------------|---------------|----------------|-----|\n';

            for (const entry of runsToShow) {
              const lhr = JSON.parse(fs.readFileSync(entry.jsonPath, 'utf8'));
              const url = new URL(lhr.finalUrl).pathname || '/';
              const cats = lhr.categories;

              comment += `| ${url} | ${formatScore(cats.performance?.score)} | ${formatScore(cats.accessibility?.score)} | ${formatScore(cats['best-practices']?.score)} | ${formatScore(cats.seo?.score)} |\n`;
            }

            comment += '\n**Key Mobile Usability Checks:**\n';
            comment += runsToShow.map(entry => {
              const lhr = JSON.parse(fs.readFileSync(entry.jsonPath, 'utf8'));
              const url = new URL(lhr.finalUrl).pathname || '/';
              const audits = lhr.audits;

              const checks = [
                { name: 'Tap Targets', key: 'tap-targets', pass: audits['tap-targets']?.score === 1 },
                { name: 'Viewport', key: 'meta-viewport', pass: audits['meta-viewport']?.score === 1 }
              ];

              return `\n**${url}:**\n` + checks.map(c =>
                `- ${c.pass ? 'âœ…' : 'âŒ'} ${c.name}`
              ).join('\n');
            }).join('\n');

            // Add deployment URL info
            const firstLhr = JSON.parse(fs.readFileSync(manifest[0].jsonPath, 'utf8'));
            const deploymentUrl = new URL(firstLhr.finalUrl).origin;
            const isProd = deploymentUrl === 'https://coopcast.tv';
            const urlLabel = isProd ? 'production' : 'Cloudflare Pages preview';
            comment += `\n\n**Tested against:** ${deploymentUrl} (${urlLabel})\n`;
            comment += `[View full reports in artifacts](https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})`;

            // Post comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });

            const botComment = comments.find(c =>
              c.user.type === 'Bot' && c.body.includes('Lighthouse CI Mobile Report')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: comment
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: comment
              });
            }
